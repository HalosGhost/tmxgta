#!/bin/bash
# tmxgta - Terminal MultipleXed Guide To Archlinux
# version 0.7.5

##    General disclaimer
#    Content is available under GNU Free Documentation License Version 1.3, 3 November 2008.
#    The content is provided "as is" without warranty of any kind, either expressed or implied,
#    including, but not limited to, the implied warranties of correctness and relevance to a 
#    particular subject. The entire risk as to the quality and accuracy of the content is with
#    you. Should the content prove substandard, you assume the cost of all necessary servicing,
#    repair, or correction.
#    See http://www.gnu.org/copyleft/fdl.html .

shopt -s extglob
shopt -s globstar

## Variables ##
STEP=1
TOTALSTEPS=14
UEFI=2
EFISTUB=2
GPT=2
[[ -z "$tmux" ]] && tmux=0
if (( "$tmux" == 1 )); then
	let COLUMNS=$(</tmp/tputout)/2
else
	COLUMNS=$(tput cols)
fi

LINES=$(tput lines)
FMTCOL=75
FMTLINE=75
ETH_NAME=$(ls /sys/class/net | grep en)
WLAN_NAME=$(ls /sys/class/net | grep wl)
KEYMAP_FILE=/tmp/selected_keymap
[ -e $KEYMAP_FILE ] && rm -rf $KEYMAP_FILE

network_configuration='./Network_configuration.html'
[ -e $network_configuration ] || network_configuration='https://wiki.archlinux.org/index.php?title=Network_Configuration'

IWDEV_OUTPUT='phy#0
        Interface wlp3s0
                ifindex 3
                wdev 0x1
                addr 00:21:6a:5e:52:bc
                type managed'

## Functions ##

# Dialog Echo
de () {
dialog --no-collapse --no-shadow  --colors --title "$TITLE" --msgbox "$1" $FMTLINE $FMTCOL
}

## Dialog Question
dq () {
if (( "$#" == 2 ));then
	dialog "$2" --no-collapse --no-shadow  --colors --title "$TITLE" --yesno "$1" $FMTLINE $FMTCOL
else
	dialog --no-collapse --no-shadow  --colors --title "$TITLE" --yesno "$1" $FMTLINE $FMTCOL
fi
}

interfacenamefunction() {
for i in /sys/class/net/*; do
	echo "==$i"
	udevadm test-builtin net_id "$i";
	echo
done 2>/dev/null
}

interfacewarning() {
echo 'Warning: As of v197, udev no longer assigns network interface names according to the wlanX and ethX naming scheme. If you are coming from a different distribution or are reinstalling Arch and not aware of the new interface naming style, please do not assume that your wireless interface is named wlan0, or that your wired interface is named eth0.
The names of your interfaces are as followed:
'
interfacenamefunction
}

findmnt_helper(){
FINDMNT=$(findmnt -o SOURCE -n /mnt)
if [[ "$FINDMNT" = '' ]]; then
	echo "List of partitions:
$(lsblk -e 7 -o NAME,TYPE,MOUNTPOINT,MODEL,RM,SIZE,FSTYPE)"
else
	echo "Hint: You are using \Z1$FINDMNT\Zn as root partition."
fi
}

interface_eth() {
[[ "$ETH_NAME" != '' ]] && echo "
Hint: Your wired interface is named \Z1$ETH_NAME\Zn."
}

interface_wlan() {
[[ "$WLAN_NAME" != '' ]] && echo "
Hint: Your wireless interface is named \Z1$WLAN_NAME\Zn."
}

partition_final_message() {
echo '
Double check and make sure that you are happy with the partition sizes as well as the partition table layout before continuing.
If you would like to start over, you can simply select Quit (or press \Z3[Q]\Zn) to exit without saving changes and then restart cfdisk (or cgdisk).
If you are satisfied, choose Write (or press \Z3[Shift+W]\Zn) to finalize and to write the partition table to the drive. Type \Z3[yes]\Zn and choose Quit (or press \Z3[Q]\Zn) to exit without making any more changes.'
}

getenter() {
key='z'
while [[ "$key" != '' ]]; do
	read -s -n 1 key
done
}

fail() {
clear
echo 'An error has occured.' 1>&2
echo "$1" 1>&2
echo '(Press enter.)' 1>&2
getenter
tput cnorm
rm -f /tmp/tputout
rm -f /tmp/tmxgta_lock
rm -f /tmp/loadkeysout
rm -f /tmp/selection
exit 1
}

trap inttrap INT
inttrap() {
fail 'User interrupted.'
}

progressbar() {
echo -n '['
i=1
while (( "$i" <= "$STEP" )); do
	echo -n '##'
	let i+=1
done
while (( "$i" <= "$TOTALSTEPS" )); do
	echo -n '-'
	let i+=1
done
echo -n ']'
}

goleft() {
(( "$tmux" == 1 )) && tmux select-pane -t 0
}

lkmenu() {
maps=()
for file in /usr/share/kbd/keymaps/i386/!(include)/**; do
	[[ ! $file =~ \.map\.gz ]] && continue
	[[ $file =~ defkeymap ]] && continue
	name=${file##*/}
	name=${name%%.*}
	maps+=("$name")
done
maps=($(printf '%s\n' "${maps[@]}"|sort))
maps=($(printf '%s\n\010\n' "${maps[@]}"))
rows=$LINES
let rows-=2
if [[ "$1" = "--select" ]]; then
	dialog --no-collapse --no-shadow --default-item 'us' --title 'Select Keyboard Layout' --ok-label 'Load keymap' --menu '' $rows 0 $rows ${maps[@]} 2> $KEYMAP_FILE
	if (( $? == 0 )); then
		loadkeys $(<$KEYMAP_FILE) &> /tmp/loadkeysout
		(( $? != 0 )) && dialog --no-collapse --no-shadow --title 'Loadkeys' --msgbox "$(</tmp/loadkeysout)" 7 $FMTCOL
	fi
else
	if [ -e $KEYMAP_FILE ]; then
		dialog --no-collapse --no-shadow --default-item '$(<$KEYMAP_FILE)' --title 'Keyboard Layouts:' --cancel-label 'Go back' --nook --menu '' $rows 0 $rows ${maps[@]}
	else
		dialog --no-collapse --no-shadow --default-item 'us' --title 'Keyboard Layouts:' --cancel-label 'Go back' --nook --menu '' $rows 0 $rows ${maps[@]}
	fi
fi
}

showtimezones() {
timezones=($(timedatectl --no-pager list-timezones))
timezones=($(printf '%s\n\010\n' "${timezones[@]}"))
rows=$LINES
let rows-=2
dialog --no-collapse --no-shadow --title 'Timezones:' --default-item 'Europe/Minsk' --cancel-label 'Go back' --nook --menu '' $rows 0 $rows ${timezones[@]}
}

##Lock file##
if [ -f /tmp/tmxgta_lock ];then
	dialog --title 'Warning' --msgbox "This script is already running." 0 0
	exit 1
fi

##Root check##
(( "$EUID" != 0 )) && dialog --title 'Warning' --yesno "This script should be run as root. Exit now?" 0 0 && exit 1

## Arguments ##
# Accept numbers as first argument to go to the step you want.
(( "$#" > 2)) && echo 'Too many arguments.' 1>&2 && getenter && exit 1
if (( "$#" > 0 ));then
	[[ "$1" =~ ^[0-9]+$ ]] && (( "$1" > 0 && "$1" <= "$TOTALSTEPS" )) && STEP="$1"
	(( "$#" == 2 )) && [[ "$2" = "1" || "$2" = "0" ]] && UEFI="$2"
fi
(( "$UEFI" == 1 )) && GPT=1

##Check Columns and Lines for readability##
if (( "$COLUMNS" <= "85" )); then
	if (( "$COLUMNS" <= "60" )); then
		dialog --title 'Warning' --yesno "Not enough columns. Exit now?" 0 0 && exit 1
		FMTCOL="$COLUMNS"
	else
		let FMTCOL="$COLUMNS"-3
	fi
else
	if (( "$COLUMNS" <= "100" )); then
		let FMTCOL="$COLUMNS"-10
	else
		FMTCOL=90
	fi
fi

if (( "$LINES" >= 50 )); then
	if (( "$LINES" >= 90 )); then
		FMTLINE=80
	else
		let FMTLINE=$LINES-10
	fi
else
	let FMTLINE=$LINES-2
fi

##Lock file##
touch /tmp/tmxgta_lock

##Invisible Cursor##
tput civis

##Intro##
if (( "$#" == 0 )); then
	dq 'Welcome to tmxgta.
Do you want to read a tutorial about this guide?'
	if (( $? == 0 )); then
		STEP=0
		(( "$tmux" == 1 )) && tmux set-option -t tmxgta status-left "tmxgta $(progressbar)" > /dev/null 2>&1
		STEP=1
		TITLE='Step 0 - Tutorial'
		if (( "$tmux" == 1 )); then
			goleft
			de 'The cursor moved to the terminal on the left, where you are automatically logged in as root.
Hit \Z3[control]\Zn-\Z3[a]\Zn two times to switch from the terminal on the left to the guide on the right.
Select \Z3[OK]\Zn in the guide to go on to the next page.' 'Step 0 - Tutorial'
		fi
		de "This program will not install archlinux, overwrite data or change the partition layout. Instead tmxgta provides an installation guide and information about the current setup.
Commands are marked \Z1# in red\Zn. When a command has to be customized for your installation its relevant part is marked \Z1\Zrlike so\Zn."
		if (( "$tmux" == 1 )); then
			de 'To scroll back in the terminal or to previous pages enter tmux copy-mode with \Z3[control]\Zn-\Z3[a]\Zn . Use pageup and pagedown for scrolling the page, and return with \Z3[enter]\Zn.'
			if [ $archiso ]; then
				de "Before starting it is recommended to read the Official Installation Guide provided by https://wiki.archlinux.org .
The Official Installation Guide and the Beginners' Guide are available as weblinks and offline on this iso image.
To view the wikipages instead of this guide go to tty2 (with ctrl+alt+f2)."
			else
				de 'Before starting it is recommended to read the Official Installation Guide provided by https://wiki.archlinux.org .'
			fi
		fi
	fi
fi
## Main loop
while (( "$STEP" <= "$TOTALSTEPS" )); do
(( "$tmux" == 1 )) && tmux set-option -t tmxgta status-left "tmxgta $(progressbar)"  > /dev/null 2>&1

## Step selection
case "$STEP" in

##1##
1) TITLE='Step 2.1 - Change the language'
dq 'Tip: These are optional for the majority of users. Useful only if you plan on writing in your own language in any of the configuration files, if you use diacritical marks in the Wi-Fi password, or if you would like to receive system messages (e.g. possible errors) in your own language.
Do you want to skip this step.?' --defaultno
if (( ! $? == 0 )); then
	lkmenu --select
	goleft
	de 'The font should also be changed, because most languages use more glyphs than the 26 letter English alphabet. Otherwise some foreign characters may show up as white squares or as other symbols. Note that the name is case-sensitive, so please type it exactly as you see it: 
\Z1# setfont Lat2-Terminus16\Zn'
	goleft
	de 'By default, the language is set to English (US). If you would like to change the language for the install process (German, in this example), remove the # in front of the locale you want from /etc/locale.gen, along with English (US). Please choose the UTF-8 entry. 
\Z1# nano /etc/locale.gen
# locale-gen
# export LANG=\Zrde_DE.UTF-8\Zn 

Remember, LAlt+LShift activates and deactivates the keymap.'
fi;;

##2##
2) if (( "$UEFI" == 2 )); then
	TITLE='Step 1.2.1 - Testing if you are booted into UEFI mode'
	goleft
	dq 'In case you have a UEFI motherboard and UEFI Boot mode is enabled (and is preferred over BIOS/Legacy mode), the CD/USB will automatically launch Arch Linux kernel (EFISTUB via Gummiboot Boot Manager). To test if you have booted into UEFI mode check if directory /sys/firmware/efi has been created: 
\Z1# ls -1 /sys/firmware/efi\Zn 

Are you booted in UEFI mode?' --defaultno
	(( $? == 0 )) && UEFI=1 || UEFI=0
fi;;

##3##
3) TITLE='Step 2.2 - Establish an internet connection'
goleft
dq "The dhcpcd network daemon starts automatically during boot and it will attempt to start a wired connection. Try to ping a server to see if a connection was established. For example, Google's DNS servers:
\Z1# ping -c 3 www.google.com\Zn

If you get a ping: unknown host error, first check if there is an issue with your cable or wireless signal strength. If not, you will need to set up the network manually.
Do you want to set up the network manually?"
if (( $? == 0 )); then
	while : ;do
		TITLE='Step 2.2 - Establish an internet connection'
		dialog --no-collapse --no-shadow --nocancel  --colors --title "$TITLE" --menu 'Do you want to configure wired or wireless networks?
For xDSL, dial-up and ISDN connections, see wikipage "Direct Modem Connection".
If you are behind a proxy server see wikipage "Proxy settings".' $FMTLINE $FMTCOL $FMTLINE 'Wired' 'wired connection via a static IP address' 'Wireless' 'wireless connectivity (Wi-Fi)' 'View Wikipage' 'https://wiki.archlinux.org/index.php/Network' 'Next step' 'Once a connection is established' 2> /tmp/selection
		if [[ "$(</tmp/selection)" = 'Wired' ]]; then
			TITLE='Step 2.2.1 - Establish an internet connection: Wired: Static IP'
			goleft
			de 'First, disable the dhcpcd service which was started automatically at boot: 
\Z1# systemctl stop dhcpcd.service\Zn'
			de "$(interfacewarning; interface_eth)"
			goleft
			de 'Alternatively identify the name of your ethernet interface manually: 
\Z1# ip link\Zn 

If you are unsure, your Ethernet interface is likely to start with the letter "e", and unlikely to be "lo" or start with the letter "w". You can also use iwconfig and see which interfaces are not wireless: 
\Z1# iwconfig\Zn'
			de "You also need to know these settings:
* Static IP address.
* Subnet mask.
* Gateway's IP address.
* Name servers (DNS) IP addresses.
* Domain name (unless you are on a local LAN, in which case you can make it up)."
			goleft
			de "Activate the connected Ethernet interface: 
\Z1# ip link set \Zr<interface>\ZR up\Zn 
$(interface_eth)
Add the address: 
\Z1# ip addr add \Zr<ip address>\ZR/\Zr<subnetmask>\ZR dev \Zr<interface>\Zn 
For example:
\Z1# ip addr add \Zr192.168.1.2/24\ZR dev enp2s0f0\Zn 

For more options, run \Z1# man ip\Zn. 

Add your gateway like this, substituting your own gateway's IP address: 
\Z1# ip route add default via \Zr<ip address>\Zn 
For example: 
\Z1# ip route add default via \Zr192.168.1.1\Zn 

Edit resolv.conf, substituting your name servers' IP addresses and your local domain name: 
\Z1# nano /etc/resolv.conf\Zn 
\Z4---------------------- 
nameserver \Zr61.23.173.5\ZR 
nameserver \Zr61.95.849.8\ZR 
search \Zrexample.com\Zn 

Note: Currently, you may include a maximum of 3 nameserver lines."
			goleft
			de 'You should now have a working network connection. 
\Z1# ping -c 3 www.google.com\Zn 

If you do not, check the detailed wikipage "Network Configuration".'
		elif [[ "$(</tmp/selection)" = 'Wireless' ]];then
			TITLE='Step 2.2.2 - Establish an internet connection: Wireless'
			de "$(interfacewarning; interface_wlan)" 
			goleft
			de "Alternatively you can identify the name of your wireless interface manually:
\Z1# iw dev\Zn 
$IWDEV_OUTPUT 

In this example, wlp3s0 is the available wireless interface. If you are unsure, your wireless interface is likely to start with the letter "w", and unlikely to be "lo" or start with the letter "e".

Note: If you do not see output similar to this, then your wireless driver has not been loaded. If this is the case, you must load the driver yourself. Please see wikipage \"Wireless Setup\" for more detailed information."
			goleft
			de "Bring the interface up with:
\Z1# ip link set \Zr<interface>\ZR up\Zn 
$(interface_wlan)
A small percentage of wireless chipsets also require firmware, in addition to a corresponding driver. If you get output like SIOCSIFFLAGS: No such file or directory, this means you will need to manually load the firmware. If unsure, invoke dmesg to query the kernel log for a firmware request from the wireless chipset. For example, if you have an Intel chipset which requires and has requested firmware from the kernel at boot:
\Z1# dmesg | grep firmware\Zn 
firmware: requesting iwlwifi-5000-1.ucode 

If there is no output, it may be concluded that the system's wireless chipset does not require firmware. 

Warning: Wireless chipset firmware packages (for cards which require them) are pre-installed under /usr/lib/firmware in the live environment (on CD/USB stick) but must be explicitly installed to your actual system to provide wireless functionality after you reboot into it! Package installation is covered later in this guide. Ensure installation of both your wireless module and firmware before rebooting! See wikipage \"Wireless Setup\" if you are unsure about the requirement of corresponding firmware installation for your particular chipset."
			goleft
			de "Next, use netctl's wifi-menu to connect to a network. 
\Z1# wifi-menu \Zr<interface>\Zn
$(interface_wlan)"
			goleft
			de 'You should now have a working network connection. 
\Z1# ping -c 3 www.google.com\Zn 

If you do not, check the detailed wikipage "Wireless Setup".'
		elif [[ "$(</tmp/selection)" = 'Next step' ]]; then
			break
		else
			if (( "$tmux" == 1 )); then
				tmux new-window "elinks $network_configuration"
			else
				elinks "$network_configuration"
			fi
		fi
	done
fi;;

##4##
4) TITLE='Step 2.3 - Prepare the storage drive'
dq '\Z1\ZrWarning: Partitioning can destroy data. You are strongly cautioned and advised to backup any critical data before proceeding.\Zn

The Arch Linux install media includes the following partitioning tools: fdisk, gdisk, cfdisk, cgdisk, parted.

Absolute beginners are encouraged to use a graphical partitioning tool. GParted is a good example, and is provided as a "live" CD. It is also included on live CDs of most Linux distributions such as Ubuntu and Linux Mint. A drive should first be partitioned and the partitions should be formatted with a file system before rebooting.
The recommendation for a system that will boot via UEFI rather than MBR legacy boot is to format the drive using a GPT partition table. This means that if the drive was previously already partitioned with an MBR (MSDOS) partition table it will now have a new partition table created which will destroy all other data on the drive. Once the new partition table has been created on a drive, only then can individual partitions be created with any chosen format type. When using Gparted, selecting the option to create a new partition table gives an "msdos" partition table by default. If you are intending to follow the advice to create a GPT partition table then you need to choose "Advanced" and then select "gpt" from the drop-down menu. This cannot be done if you have a pre-existing Windows installation on the drive which you wish not to destroy. It is therefore extremely important to not change the partition table to GPT if you intend on having a dual boot system. Leave the Windows install untouched and try to get the Linux install working with UEFI on a drive that contains an MBR (legacy) partition table.
In addition, some newer computers come pre-installed with Windows 8 which will be using Secure Boot. Arch Linux currently does not support Secure Boot, but some Windows 8 installations have been seen not to boot if Secure Boot is turned off in the BIOS. In some cases it is necessary to turn off both Secure Boot as well as Fastboot in the BIOS options in order to allow Windows 8 to boot without Secure Boot. However there are potential security risks in turning off Secure Boot for booting up Windows 8. Therefore, it may be a better option to keep the Windows 8 install intact and have an independent hard drive for the Linux install - which can then be partitioned from scratch using a GPT partition table. Once that is done, creating several ext4/FAT32/swap partitions on the second drive may be a better way forward if the computer has two drives available. This is often not easy or possible on a small laptop. Currently, Secure Boot is still not in a fully stable state for reliable operation, even for Linux distributions that support it.

See wikipage "Swap" for details if you wish to set up a swap partition or swap file. A swap file is easier to resize than a partition and can be created at any point after installation, but cannot be used with a Btrfs filesystem. 

Note: If you are installing to a USB flash key, see wikipage "Installing Arch Linux on a USB key".

If you have already created the partitions and filesystems for archlinux, proceed to Mount the partitions. 

Do you want to skip this section?' --defaultno
if (( ! $? == 0 )); then
	TITLE='Step 2.3 - Prepare the storage drive'
	if (( "$UEFI" == 1 ));then
		de 'Notes regarding UEFI boot:
* If you have a UEFI motherboard, you will need to create an extra UEFI System Partition.

* It is recommended to always use GPT for UEFI boot, as some UEFI firmwares do not allow UEFI-MBR boot.

* "UEFI System Partition" has been shortened to "ESP" in this guide.'
		GPT=1
	elif (( "$UEFI" == 0 ));then
		dialog --no-collapse --no-shadow  --colors --title "$TITLE" --yes-label 'MBR' --no-label 'GPT' --defaultno --yesno 'Note regarding GPT partitioning: 
* If you are not dual booting with Windows, then it is advisable to use GPT instead of MBR. Read wikipage "GPT" for a list of advantages.

* If you have a BIOS motherboard (or plan on booting in BIOS compatibility mode) and you want to setup GRUB on a GPT-partitioned drive, you will need to create an extra BIOS Boot Partition of size 1007 KiB and EF02 type code. Syslinux does not need one.

* Some BIOS systems may have issues with GPT. See wikipage "GPT#BIOS_Systems" for more info and possible workarounds. 

Choose either MBR or GPT. Do not choose both!' $FMTLINE $FMTCOL
		(( $? == 0 )) && GPT=0 || GPT=1
	else
		fail 'Please set the UEFI variable correctly.'
	fi
	if (( $GPT == 0 )); then
		TITLE='Step 2.3 - Prepare the storage drive: MBR: cfdisk'
		goleft
		de "List of devices: 
$(lsblk -e 7 -o NAME,TYPE,MOUNTPOINT,MODEL,RM,SIZE,FSTYPE) 

Each partition is identified with a number suffix. For example, sda1 specifies the first partition of the first drive, while sda designates the entire drive.

See the following example: 

The example system will contain a 15 GiB root partition, and a home partition for the remaining space. It should be emphasized that partitioning is a personal choice and that this example is only for illustrative purposes. See wikipage \"Partitioning\". 

Start cfdisk, a curses-based program for partitioning MBR hard disk drives. 
Replace \Z1x\Zn with your actual harddrive / storage device. 
\Z1# cfdisk /dev/sd\Zrx\Zn"
		goleft
		de "Root partition: 
> Choose New (or press \Z3[N]\Zn) 
> \Z3[Enter]\Zn for Primary 
> Type in \Z3[15360]\Zn for a size of 15360 mebibytes 
> \Z3[Enter]\Zn for Beginning 
> \Z3[Enter]\Zn for Bootable. 

Home partition: 
> Press the \Z3[down arrow]\Zn to move to the free space area. 
> Choose New (or press \Z3[N]\Zn) 
> \Z3[Enter]\Zn for Primary 
> \Z3[Enter]\Zn to use the rest of the drive (or you could type in the desired size). 

Here is what it should look like:
Name   Flags     Part Type  FS Type Size (MB) 
--------------------------------------------- 
sdx1   Boot      Primary    Linux       15360 
sdx2             Primary    Linux      123450 
$(partition_final_message)"
	else	
		TITLE='Step 2.3 - Prepare the storage drive: GPT: cgdisk'
		if (( "$UEFI" == 1 ));then
			goleft
			de "List of devices: 
$(lsblk -e 7 -o NAME,TYPE,MOUNTPOINT,MODEL,RM,SIZE,FSTYPE) 

Each partition is identified with a number suffix. For example, sda1 specifies the first partition of the first drive, while sda designates the entire drive.

See the following example: 

The example system will contain a 512 MiB ESP, a 15 GiB root partition, and a home partition for the remaining space. It should be emphasized that partitioning is a personal choice and that this example is only for illustrative purposes. See wikipage \"Partitioning\". 

Start cgdisk, a curses-based program for partitioning GPT hard disk drives. 
Replace \Z1x\Zn with your actual harddrive / storage device. 
\Z1# cgdisk /dev/sd\Zrx\Zn"
			goleft
			de "ESP: 
> Choose New (or press \Z3[N]\Zn) 
> \Z3[Enter]\Zn for the first sector (2048) 
> Type in \Z3[512M]\Zn for a size of 512 mebibytes 
> Type in \Z3["EF00"]\Zn for disk type code "EF00" 
> \Z3[Enter]\Zn for a blank partition name. 
> Recommended: Type in "ESP" as name so you can easily recognize the partition. 

Note: Size >=512 MiB for ESP is recommended for most compatibility. However ESP with size >=100 MiB are also allowed by many Linux distros and by Microsoft Windows, hence smaller partitions are fine. 

Note: The code "EF00" on a GPT partition marks that partition as ESP. 

Root partition: 
> Press the \Z3[down arrow]\Zn a couple of times to move to the larger free space area. 
> Choose New (or press \Z3[N]\Zn) 
> \Z3[Enter]\Zn for the first sector 
> Type in \Z3[15G]\Zn for a size of 15 gibibytes 
> \Z3[Enter]\Zn for the default hex code (8300) 
> \Z3[Enter]\Zn for a blank partition name. 
> Or type in a name like for example "archroot". 

Home partition: 
> Press the \Z3[down arrow]\Zn a couple of times to move to the larger free space area. 
> Choose New (or press \Z3[N]\Zn) 
> \Z3[Enter]\Zn for the first sector 
> \Z3[Enter]\Zn to use the rest of the drive 
> (or you could type in the desired size; for example \"30G\"). 
> \Z3[Enter]\Zn for the default hex code (8300) 
> \Z3[Enter]\Zn for a blank partition name. 

Here is what it should look like: 
Part. #     Size        Partition Type 
---------------------------------------- 
            1007.0 KiB  free space 
   1        512.0 MiB   EFI System 
   2        15.0 GiB    Linux filesystem 
   3        X.Y GiB     Linux filesystem 
$(partition_final_message)"
		else
			goleft
			de "List of devices: 
$(lsblk -e 7 -o NAME,TYPE,MOUNTPOINT,MODEL,RM,SIZE,FSTYPE) 

Each partition is identified with a number suffix. For example, sda1 specifies the first partition of the first drive, while sda designates the entire drive.

See the following example: 

The example system will contain a 15 GiB root partition, and a home partition for the remaining space. It should be emphasized that partitioning is a personal choice and that this example is only for illustrative purposes. See wikipage \"Partitioning\". 

Start cgdisk, a curses-based program for partitioning GPT hard disk drives. 
Replace \Z1x\Zn with your actual harddrive / storage device. 
\Z1# cgdisk /dev/sd\Zrx\Zn"
			goleft
			de "Root partition: 
> Choose New (or press \Z3[N]\Zn) 
> \Z3[Enter]\Zn for the first sector (2048) 
> Type in \Z3[15G]\Zn for a size of 15 gibibytes 
> \Z3[Enter]\Zn for the default hex code (8300) 
> \Z3[Enter]\Zn for a blank partition name. 

Home partition: 
> Press the \Z3[down arrow]\Zn a couple of times to move to the larger free space area. 
> Choose New (or press \Z3[N]\Zn) 
> \Z3[Enter]\Zn for the first sector 
> \Z3[Enter]\Zn to use the rest of the drive 
> (or you could type in the desired size; for example "30G"). 
> \Z3[Enter]\Zn for the default hex code (8300) 
> \Z3[Enter]\Zn for a blank partition name. 

Here is how it should look like: 
Part. #     Size        Partition Type 
---------------------------------------- 
            1007.0 KiB  free space 
   1        15.0 GiB    Linux filesystem 
   2        283.1 GiB   Linux filesystem 
$(partition_final_message)"
		fi
	fi
	TITLE='Step 2.3 - Prepare the storage drive: Create filesystems'
	if (( "$UEFI" == 1 ));then
		goleft
		de "List of partitions: 
$(lsblk -e 7 -o NAME,TYPE,MOUNTPOINT,MODEL,RM,SIZE,FSTYPE) 

Simply partitioning is not enough; the partitions also need a filesystem. 
To format the partitions with an ext4 filesystem: 
\Z1\ZrWarning: Double check and triple check that it is actually /dev/sdxY and /dev/sdxZ that you want to format.\Zn 
\Z1# mkfs.ext4 /dev/sd\ZrxY\ZR 
# mkfs.ext4 /dev/sd\ZrxZ\Zn 

If you have made a partition dedicated to swap (code 82), do not forget to format and activate it with: 
\Z1# mkswap /dev/sd\ZrxY\ZR 
# swapon /dev/sd\ZrxY\Zn 

You have created an ESP before. The ESP must be formatted as FAT32, to allow the Firmware to read and launch UEFI applications from the ESP. Format the ESP partition as FAT32: 
\Z1# mkfs.vfat -F32 /dev/sd\ZrxW\Zn"
	else
		goleft
		de "List of partitions: 
$(lsblk -e 7 -o NAME,TYPE,MOUNTPOINT,MODEL,RM,SIZE,FSTYPE) 

Simply partitioning is not enough; the partitions also need a filesystem. 
To format the partitions with an ext4 filesystem: 
\Z1\ZrWarning: Double check and triple check that it is actually /dev/sdxY and /dev/sdxZ that you want to format.\Zn 
\Z1# mkfs.ext4 /dev/sd\ZrxY\ZR 
# mkfs.ext4 /dev/sd\ZrxZ\Zn 

If you have made a partition dedicated to swap (code 82), do not forget to format and activate it with: 
\Z1# mkswap /dev/sd\ZrxY\ZR 
# swapon /dev/sd\ZrxY\Zn"
	fi
	TITLE='Step 2.3 - Prepare the storage drive'
	de "Partition and Filesystem Layout: 
$(lsblk -e 7 -o NAME,TYPE,MOUNTPOINT,MODEL,RM,SIZE,FSTYPE)"
fi;;


##5##
5) TITLE='Step 2.4 - Mount the partitions'
goleft
de "Partition and Filesystem Layout: 
$(lsblk -e 7 -o NAME,TYPE,MOUNTPOINT,MODEL,RM,SIZE,FSTYPE) 

Note: Do not mount more than one partition to the same directory. And pay attention, because the mounting order is important. 

First, mount the root partition on /mnt. 
\Z1# mount /dev/sd\ZrxX\ZR /mnt\Zn"
goleft
de "Partition and Filesystem Layout: 
$(lsblk -e 7 -o NAME,TYPE,MOUNTPOINT,MODEL,RM,SIZE,FSTYPE) 

Note: Do not mount more than one partition to the same directory. And pay attention, because the mounting order is important. 

First, mount the root partition on /mnt. 
\Z1# mount /dev/sd\ZrxX\ZR /mnt\Zn 

Then mount the home partition and any other separate partition (/boot, /var, etc), if you have any: 
\Z1# mkdir /mnt/home 
# mount /dev/sd\ZrxY\ZR /mnt/home\Zn"
if (( "$UEFI" == 1 )); then
	de "Partition and Filesystem Layout:
$(lsblk -e 7 -o NAME,TYPE,MOUNTPOINT,MODEL,RM,SIZE,FSTYPE)

You have a UEFI motherboard, therefore mount the ESP:
\Z1# mkdir /mnt/boot
# mount /dev/sd\ZrxZ\ZR /mnt/boot\Zn"
fi
goleft

de "Final Mountpoints: 
$(lsblk -e 7 -o NAME,TYPE,MOUNTPOINT,MODEL,RM,SIZE,FSTYPE)";;

##6##
6) TITLE='Step 2.5 - Select a mirror'
dq 'Before installing, you may want to edit the mirrorlist file and place your preferred mirror first. A copy of this file will be installed on your new system by pacstrap as well, so it is worth getting it right. 
\Z1# nano /etc/pacman.d/mirrorlist\Zn 

If you want, you can make it the only mirror available by getting rid of everything else, but it is usually a good idea to have a few more, in case the first one goes offline. 

Generate a new optimised mirrorlist with reflector?'
if (( $? == 0 )); then
	dialog --no-collapse --no-shadow  --colors --infobox 'Looking for mirrors. Please wait...' 3 40
	if reflector -f 5 -l 5 -a 5 --sort score -p http --save /tmp/mirrorlist; then
		goleft
		de "$(tail -n 5 /tmp/mirrorlist) 

The mirrorlist above has been saved to /tmp/mirrorlist. Copy it to /etc/pacman.d/mirrorlist if you want to install it on your new system. 
\Z1# cp /tmp/mirrorlist /etc/pacman.d/mirrorlist\Zn"
	fi
fi;;

##7##
7) TITLE='Step 2.6 - Install the base system'
goleft
de 'The base system is installed using the pacstrap script. The -i switch can be omitted if you wish to install every package from the base group without prompting. 
\Z1# pacstrap -i /mnt base\Zn 

Note: If pacman fails to verify your packages, check the system time with cal. If the system date is invalid (e.g. it shows the year 2010), signing keys will be considered expired (or invalid), signature checks on packages will fail and installation will be interrupted. Make sure to correct the system time, either by doing so manually or with the ntp client, and retry running the pacstrap command. Refer to the "Time" wikipage for more information on correcting system time. 

Note: If pacman complains that error: failed to commit transaction (invalid or corrupted package), run the following command: 
# pacman-key --init && pacman-key --populate archlinux 

This will give you a basic Arch system. Other packages can be installed later using pacman.';;

##8##
8) TITLE='Step 2.7 - Generate an fstab'
goleft
de 'Generate an fstab file with the following command. UUIDs will be used because they have certain advantages. (See wikipage "fstab#Identifying filesystems".) If you would prefer to use labels instead, replace the -U option with -L. 
\Z1# genfstab -U -p /mnt >> /mnt/etc/fstab 
# nano /mnt/etc/fstab\Zn 

Warning: The fstab file should always be checked after generating it. If you encounter errors running genfstab or later in the install process, do not run genfstab again; just edit the fstab file. 

A few considerations: 
* The last field determines the order that in which partitions are checked at start up : 1 , 2 or 0 (See wikipage "fstab#Field definitions".)

* Only the root (/) partition needs 1 for the last field. Everything else should have either 2 or 0

* You will normally want your swap partition to have 0 i.e. "do not check".';;

##9##
9) TITLE='Step 2.8 - Chroot and configure the base system'
goleft
de 'Next, we chroot into our newly installed system: 
\Z1# arch-chroot /mnt\Zn 

Note: Use arch-chroot /mnt /bin/bash to chroot into a bash shell. 

At this stage of the installation, you will configure the primary configuration files of your Arch Linux base system. These can either be created if they do not exist, or edited if you wish to change the defaults. 
Closely following and understanding these steps is of key importance to ensure a properly configured system.'
TITLE='Step 2.8 - Configuration [1/6]: Locale'
goleft
de 'Locales are used by glibc and other locale-aware programs or libraries for rendering text, correctly displaying regional monetary values, time and date formats, alphabetic idiosyncrasies, and other locale-specific standards. 

There are two files that need editing: locale.gen and locale.conf. 
* The locale.gen file is empty by default (everything is commented out) and you need to remove the # in front of the line(s) you want. You may uncomment more lines than just English (US), as long as you choose their UTF-8 encoding: 
\Z1# nano /etc/locale.gen\Zn 
\Z4----------------- 
en_US.UTF-8 UTF-8 
\Zrde_DE.UTF-8 UTF-8\Zn 

\Z1# locale-gen\Zn 
This will run on every glibc upgrade, generating all the locales specified in /etc/locale.gen. 

* The locale.conf file does not exist by default. Setting only LANG should be enough. It will act as the default value for all other variables. 
\Z1# echo LANG=\Zren_US.UTF-8\ZR > /etc/locale.conf 
# export LANG=\Zren_US.UTF-8\Zn 

Note: If you set some other language than English at the beginning of the install, the above commands would be something like: 
\Z1# echo LANG=\Zrde_DE.UTF-8\ZR > /etc/locale.conf 
# export LANG=\Zrde_DE.UTF-8\Zn 

To use other locales for other LC_* variables, run "locale" to see the available options and add them to locale.conf. It is not recommended to set the LC_ALL variable.'

TITLE='Step 2.8 - Configuration [2/6]: Console font and keymap'
while : ;do
	dialog --no-collapse --no-shadow  --colors --yes-label '"OK"' --defaultno --no-label '"LAYOUTS"' --title "$TITLE" --yesno 'If you set a keymap at the beginning of the install process, load it now, as well, because the environment has changed. 
\Z1# loadkeys \Zrlayout\Zn 
For a list of available layouts select "LAYOUTS". 

Change the font. 
\Z1# setfont Lat2-Terminus16\Zn 

To make them available after reboot, edit vconsole.conf. 
\Z1# nano /etc/vconsole.conf\Zn 
\Z4-------------------- 
KEYMAP=\Zrlayout\ZR 
FONT=Lat2-Terminus16\Zn 

KEYMAP – Please note that this setting is only valid for your TTYs, not any graphical window managers or Xorg. 

FONT – Available alternate console fonts reside in /usr/share/kbd/consolefonts/. The default (blank) is safe, but some foreign characters may show up as white squares or as other symbols. It is recommended that you change it to Lat2-Terminus16, because it claims to support "about 110 language sets". 

Possible option FONT_MAP – Defines the console map to load at boot. Read man setfont. Removing it or leaving it blank is safe. 

See wikipage "Console fonts" and man vconsole.conf for more information.' $FMTLINE $FMTCOL
	if (( ! $? == 0 )); then
		lkmenu
	else
		break
	fi
done

TITLE='Step 2.8 - Configuration [3/6]: Timezone'
while : ;do
	dialog --no-collapse --no-shadow  --colors --yes-label '"OK"' --defaultno --no-label '"ZONES"' --title "$TITLE" --yesno 'Create a symbolic link /etc/localtime to your zone file /usr/share/zoneinfo/<Zone>/<SubZone> using this command: 
\Z1# ln -s /usr/share/zoneinfo/\Zr<Zone>\ZR/\Zr<SubZone>\ZR /etc/localtime\Zn 

Example: 
\Z1# ln -s /usr/share/zoneinfo/\ZrEurope\ZR/\ZrMinsk\ZR /etc/localtime\Zn 

For a list of zones and subzones select "ZONES".' $FMTLINE $FMTCOL
	if (( ! $? == 0 )); then
		showtimezones
	else
		break
	fi
done

TITLE='Step 2.8 - Configuration [4/6]: Hardware clock'
while : ;do
	dialog --no-collapse --no-shadow  --colors --no-label 'NEXT' --title "$TITLE" --yesno 'Set the hardware clock mode uniformly between your operating systems. Otherwise, they may overwrite the hardware clock and cause time shifts. You can generate /etc/adjtime automatically by using one of the following commands: 

* First option: UTC (recommended) 
\Z1# hwclock --systohc --utc\Zn 

Note: Using UTC for the hardware clock does not mean that software will display time in UTC. 

* Second option: localtime (discouraged; used by default in Windows) 
\Z1# hwclock --systohc --localtime\Zn 

Warning: Using localtime may lead to several known and unfixable bugs. However, there are no plans to drop support for localtime. 

Do you want to view information about dual boot setup with Windows?' $FMTLINE $FMTCOL --ok-label 'Go back' --msgbox '* Recommended: 
Set both Arch Linux and Windows to use UTC. A quick registry fix is needed. Also, be sure to prevent Windows from synchronizing the time on-line, because the hardware clock will default back to localtime. 

* Not recommended: 
Set Arch Linux to localtime and disable any time-related services, like NTPd. This will let Windows take care of hardware clock corrections and you will need to remember to boot into Windows at least two times a year (in Spring and Autumn) when DST kicks in. So please do not ask on the forums why the clock is one hour behind or ahead if you usually go for days or weeks without booting into Windows.' 0 0 || break
done

TITLE='Step 2.8 - Configuration [5/6]: Kernel modules'
dq 'This is just an example, you do not need to set it. All needed modules are automatically loaded by udev, so you will rarely need to add something here. Only add modules that you know are missing. 

Do you want to skip this step?'
if (( ! $? == 0 )); then
	goleft
	de 'For kernel modules to load during boot, place a *.conf file in /etc/modules-load.d/, with a name based on the program that uses them. 
\Z1# nano /etc/modules-load.d/\Zrmymodule\ZR.conf\Zn 
\Z4-------- 
\Zrmymodule\Zn 

If there are more modules to load per *.conf, the module names can be separated by newlines. Empty lines and lines starting with # or ; are ignored.'
fi

TITLE='Step 2.8 - Configuration [6/6]: Hostname'
goleft
de 'Set the hostname to your liking (e.g. \Z1\Zrarch\Zn): 
\Z1# echo \Zrmyhostname\ZR > /etc/hostname\Zn 

Note: There is no need to edit /etc/hosts.';;

##10##
10) TITLE='Step 2.9 - Configure the network'
dialog --no-collapse --no-shadow --nocancel  --colors --title "$TITLE" --menu 'You need to configure the network again, but this time for your newly installed environment. The procedure and prerequisites are very similar to the one described before, except we are going to make it persistent and automatically run at boot. 

For xDSL, dial-up and ISDN connections, see wikipage "Direct Modem Connection". 

If you are behind a proxy server see wikipage "Proxy settings". 

Note: If you would like to use the old interface naming scheme (ie. eth* and wlan*) you can accomplish this by creating an empty file at /etc/udev/rules.d/80-net-name-slot.rules which will mask the file of the same name located under /usr/lib/udev/rules.d (alternatively, instead of an empty file, using a symlink to /dev/null is also an acceptable masking method).

Note: For more in-depth information on network configuration, visit wikipages "Network Configuration" and "Wireless Setup". ' $FMTLINE $FMTCOL $FMTLINE 'Wired' 'Static or Dynamic' 'Wireless' 'WIFI' 'SKIP' 'Not recommended' 2> /tmp/selection
 
if [[ "$(</tmp/selection)" = 'Wired' ]]; then
	TITLE='Step 2.9.1 - Configure the network: Wired'
	dialog --no-collapse --no-shadow  --colors --yes-label '"DYNAMIC"' --no-label '"STATIC"' --title "$TITLE" --yesno 'Do you want to you use dynamic (dhcp) or static ip adresses?' $FMTLINE $FMTCOL
	if (( $? == 0 )); then
		TITLE='Step 2.9.1 - Configure the network: Wired: Dynamic IP'
		dialog --no-collapse --no-shadow  --colors --ok-label '"SYSTEMD"' --extra-button --extra-label '"NETCTL-IFPLUGD"' --cancel-label '"NETCTL"' --title "$TITLE" --yesno 'Do you want to use a single fixed wired network connection (systemd dhcpcd.service), or do you need a network management service (netctl-ifplugd), which gracefully handles dynamic connections to new networks?' $FMTLINE $FMTCOL
		case $? in
		0)	TITLE='Step 2.9.1 - Configure the network: Wired: Dynamic IP: Dhcpcd service'
			goleft
			de "Enable the dhcpcd service. 
\Z1# systemctl enable dhcpcd@\Zrinterface\ZR.service\Zn 
$(interface_eth)";;
		1)	TITLE='Step 2.9.1 - Configure the network: Wired: Dynamic IP: netctl'
			goleft
			de "Copy a sample profile from /etc/netctl/examples to /etc/netctl/:
\Z1# cd /etc/netctl
# cp examples/ethernet-dhcp \Zrmy-network\Zn

Edit the profile as needed (modify \Z1Interface\Zn):
\Z1# nano \Zrmy-network\Zn
$(interface_eth)
Enable the my-network profile:
\Z1# netctl enable \Zrmy-network\Zn";;
		3)	TITLE='Step 2.9.1 - Configure the network: Wired: Dynamic IP: netctl-ifplugd'
			goleft
			de "Install ifplugd, which is required for netctl-ifplugd: 
\Z1# pacman -S ifplugd\Zn 

Then enable netctl with your interface as argument: 
\Z1# systemctl enable netctl-ifplugd@\Zrinterface\ZR.service\Zn 
$(interface_eth)
Note: Netctl also provides netctl-auto, which can be used to handle wired profiles in conjunction with netctl-ifplugd.";;
		*)	fail 'Dialog selection.';;
	esac
	else
		TITLE='Step 2.9.1 - Configure the network: Wired: Static IP'
		goleft
		de "Copy a sample profile from /etc/netctl/examples to /etc/netctl: 
\Z1# cd /etc/netctl 
# cp examples/ethernet-static \Zrmy-network\Zn 

Edit the profile as needed, modify \Z1Interface\Zn, \Z1Address\Zn, \Z1Gateway\Zn and \Z1DNS\Zn. 
\Z1# nano \Zrmy-network\Zn 
$(interface_eth)
Notice the /24 in Address which is the CIDR notation of a 255.255.255.0 netmask.

Enable above created profile to start it at every boot:
\Z1# netctl enable \Zrmy-network\Zn"
	fi
elif [[ "$(</tmp/selection)" = 'Wireless' ]]; then
	TITLE='Step 2.9.2 - Configure the network: Wireless:'
	goleft
	de 'Note: If your wireless adapter requires a firmware, (as described in the step Establish an internet connection) install the package containing your firmware. Most of the time, the linux-firmware package will contain the needed firmware. Though for some devices, the required firmware might be in its own package. For example: 
\Z1# pacman -S \Zrzd1211-firmware\Zn

See wikipage "Wireless Setup" for more info.

Install iw, wpa_supplicant and wpa_actiond which you will need to connect to a network:
\Z1# pacman -S iw wpa_supplicant wpa_actiond\Zn'
	while : ;do
		dialog --no-collapse --no-shadow --nocancel  --colors --title "$TITLE" --menu 'There are different options for adding wireless networks:' $FMTLINE $FMTCOL $FMTLINE 'wifi-menu' 'Select interactively from a menu of available networks.' 'manual netctl profiles' 'A fixed network profile.' 'netctl-auto' 'Connect automaticly to known networks.' 'Next step' '' 2> /tmp/selection

		if [[ "$(</tmp/selection)" = 'wifi-menu' ]]; then
			de 'Install dialog, which is required for wifi-menu:
\Z1# pacman -S dialog\Zn

After finishing the rest of this installation and rebooting, you can connect to the network with wifi-menu interface (where interface is the interface of your wireless chipset). 
(# wifi-menu interface)

Warning: If you are using wifi-menu, this must be done *after* your reboot when no longer chrooted. The process spawned by this command will conflict with the one you have running outside of the chroot. Alternatively, you could just configure a network profile manually using the templates previously mentioned so that you do not have to worry about using wifi-menu at all.'
		elif [[ "$(</tmp/selection)" = 'manual netctl profiles' ]]; then
			goleft
			de "Copy a network profile from /etc/netctl/examples to /etc/netctl:
\Z1# cd /etc/netctl
# cp examples/wireless-wpa \Zrmy-network\Zn

Edit the profile as needed (modify \Z1Interface\Zn, \Z1ESSID\Zn and \Z1Key\Zn):
\Z1# nano \Zrmy-network\Zn
$(interface_wlan)"
		elif [[ "$(</tmp/selection)" = 'netctl-auto' ]]; then
			goleft
			de "Enable the netctl-auto service, which will connect to known networks and gracefully handle roaming and disconnects: 
\Z1# systemctl enable netctl-auto@\Zrinterface\ZR.service\Zn
$(interface_wlan)
Note: Netctl also provides netctl-ifplugd, which can be used to handle wired profiles in conjunction with netctl-auto."
		elif [[ "$(</tmp/selection)" = 'Next step' ]]; then
			break
		fi
	done
fi;;

##11##
11) TITLE='Step 2.10 - Create an initial ramdisk environment'
dq 'Tip: Most users can skip this step and use the defaults provided in mkinitcpio.conf. The initramfs image (from the /boot folder) has already been generated based on this file when the linux package (the Linux kernel) was installed earlier with pacstrap. 
Here you need to set the right hooks if the root is on a USB drive, if you use RAID, LVM, or if /usr is on a separate partition. 

Do you want to skip this step?'
if (( ! $? == 0 )); then
	while : ;do
		dialog --no-collapse --no-shadow  --colors --yes-label '"OK"' --defaultno --no-label '"HOOKS"' --title "$TITLE" --yesno 'Select "HOOKS" for a list of hooks and their usage. 
Edit /etc/mkinitcpio.conf as needed. 
\Z1# nano /etc/mkinitcpio.conf\Zn 

Re-generate the initramfs image. 
\Z1# mkinitcpio -p linux\Zn 

Note: Arch VPS installations on QEMU (e.g. when using virt-manager) may need virtio modules in mkinitcpio.conf to be able to boot. MODULES="virtio virtio_blk virtio_pci virtio_net"' $FMTLINE $FMTCOL
		if (( ! $? == 0 )); then
			if (( "$tmux" == 1 )); then
				tmux new-window 'elinks https://wiki.archlinux.org/index.php/Mkinitcpio#Common_hooks'
			else
				elinks https://wiki.archlinux.org/index.php/Mkinitcpio#Common_hooks
			fi
		else
			break
		fi
	done
fi;;

##12##
12) TITLE='Step 2.11 - Set the root password'
goleft
de 'Set the root password with: 
\Z1# passwd\Zn';;

##13##
13)if (( "$UEFI" == 1 )); then
	TITLE='Step 2.12 - Install and configure a bootloader: UEFI'
	dialog --no-collapse --no-shadow  --colors --yes-label '"EFISTUB"' --no-label '"GUMMIBOOT"' --title "$TITLE" --yesno 'For UEFI boot, the drive needs to be GPT-partitioned and an ESP (512 MiB or larger, type EF00, formatted with FAT32) must be present and mounted on /boot. If you have followed this guide from the beginning, you have already done all of these.
For UEFI systems, two options are available. Choose one as per your convenience.
* Boot the Linux kernel directly using EFISTUB.
* gummiboot is a simple bootloader, useful if you are dual booting.' $FMTLINE $FMTCOL
	if (( $? == 0 )) ;then
		TITLE='Step 2.12.2.1 - Install and configure a bootloader: UEFI: EFISTUB'
		goleft
		de "Install the efibootmgr package and then add an Arch Linux boot entry, replacing /dev/sdaX with your root partition:
\Z1# pacman -S efibootmgr
# efibootmgr -c -L \"Arch Linux\" -l /vmlinuz-linux -u \"root=/dev/sda\ZrX\ZR ro quiet initrd=/initramfs-linux.img\"\Zn

$(findmnt_helper)"
	else
		TITLE='Step 2.12.2.2 - Install and configure a bootloader: UEFI: Gummiboot Loader'
		goleft
		de "Install the gummiboot package and then run gummiboot install to install the bootloader:
\Z1# pacman -S gummiboot
# gummiboot install\Zn

Warning: You will probably see an error during gummiboot install, when it fails to add itself to NVRAM because of a bug. If you get this error message, manually use efibootmgr to add gummiboot to NVRAM:
\Z1# efibootmgr -c -w -l '\EFI\gummiboot\gummibootx64.efi' -L \"Gummiboot\"\Zn

You will need to manually create a configuration file to add an entry for Arch Linux to the gummiboot loader. Create /boot/loader/entries/arch.conf and add the following contents, replacing /dev/sdaX with your root partition.
\Z1# nano /boot/loader/entries/arch.conf\Zn
\Z4-----------------------------------
title          Arch Linux
linux          /vmlinuz-linux
initrd         /initramfs-linux.img
options        root=/dev/sda\ZrX\ZR ro\Zn

$(findmnt_helper)"
	fi
elif (( "$UEFI" == 0 )); then
	TITLE='Step 2.12.1 - Install and configure a bootloader: BIOS'
	dialog --no-collapse --no-shadow  --colors --yes-label '"Syslinux"' --no-label '"GRUB"' --title "$TITLE" --yesno 'For BIOS systems, two bootloaders are available: Syslinux and GRUB. Choose the bootloader as per your convenience.
* Syslinux is (currently) limited to loading only files from the partition where it was installed. Its configuration file is considered to be easier to understand.

* GRUB is more feature-rich and supports more complex scenarios. Its configuration file(s) is more similar to a scripting language, which may be difficult for beginners to manually write. It is recommended that they automatically generate one.

Note: If you have a GPT-partitioned drive GRUB needs a "BIOS Boot Partition". If the partition is not present and your drive is GPT-partitioned choose Syslinux instead!' $FMTLINE $FMTCOL
	if (( $? == 0 )); then
		TITLE='Step 2.12.1.1 - Install and configure a bootloader: BIOS: Syslinux'
		goleft
		de 'Install the syslinux package. 
\Z1# pacman -S syslinux\Zn 

Note: If you opted for a GUID partition table for your hard drive earlier, you need to install the gptfdisk package now for this next step to work, assuming you have not installed it already.
\Z1# pacman -S gptfdisk\Zn

Use the syslinux-install_update script to automatically install the bootloader (-i), mark the partition active by setting the boot flag (-a), and install the MBR boot code (-m): 
\Z1# syslinux-install_update -i -a -m\Zn'
		goleft
		de "Configure syslinux.cfg to point to the right root partition. This step is vital. If it points to the wrong partition, Arch Linux will not boot. Change /dev/sd\Z1xY\Zn to reflect your root partition. Do the same for the fallback entry.

$(findmnt_helper)

\Z1# nano /boot/syslinux/syslinux.cfg\Zn
\Z4-----------------------------
...
LABEL arch

   ...
   APPEND root=/dev/sd\ZrxY\ZR ro
   ...\Zn

For more information on configuring and using Syslinux, see wikipage \"Syslinux\"."
	else
		TITLE='Step 2.12.2.2 - Install and configure a bootloader: BIOS: GRUB'
			de "Install the grub package. 
\Z1# pacman -S grub\Zn 

Run grub-install /dev/sd\Z1x\Zn: 

Note: Change /dev/sd\Z1x\Zn to reflect the drive you installed Arch on. Do not append a partition number (do not use sdxY). 

$(findmnt_helper)

\Z1# grub-install --recheck /dev/sd\Zrx\Zn 

While using a manually created grub.cfg is absolutely fine, it is recommended that beginners automatically generate one: 

Tip: To automatically search for other operating systems on your computer, install os-prober (pacman -S os-prober) before running the next command. 

\Z1# grub-mkconfig -o /boot/grub/grub.cfg\Zn

For more information on configuring and using GRUB, see wikipage \"GRUB\"."
	fi
else	
	fail 'Please set the UEFI variable correctly.'
fi;;

##14##
14) TITLE='Step 2.13 - Unmount the partitions and reboot'
goleft
de 'Exit from the chroot environment: 
\Z1# exit\Zn'
goleft
de "List of partitions: 
$(lsblk -e 7 -o NAME,TYPE,MOUNTPOINT) 

Since the partitions are mounted under /mnt, we use the following command to unmount them: 
\Z1# umount /mnt/{boot,home,}\Zn 

Note: There is no need to unmount /run/archiso."
goleft
de "List of partitions: 
$(lsblk -e 7 -o NAME,TYPE,MOUNTPOINT) 

Since the partitions are mounted under /mnt, we use the following command to unmount them: 
\Z1# umount /mnt/{boot,home,}\Zn 

Note: There is no need to unmount /run/archiso."
(( "$tmux" == 1 )) && tmux set-option -t tmxgta status-left 'COMPLETE' > /dev/null 2>&1
dialog --no-collapse --sleep 3 --no-shadow  --colors --title "$TITLE" --infobox "Reboot the computer: 
\Z1# reboot\Zn 

Tip: Be sure to remove the installation media, otherwise you will boot back into it." $FMTLINE $FMTCOL --and-widget --ok-label 'EXIT' --msgbox "Thank you for following tmxgta." 5 35
(( "$tmux" == 1 )) && tmux set-option -t tmxgta status-left 'reboot' > /dev/null 2>&1
;;

## Closing step selection
esac
	let STEP+=1
## Closing main loop
done

tput cnorm
rm -f /tmp/tmxgta_lock
rm -f /tmp/loadkeysout
rm -f /tmp/selection
rm -f /tmp/tputout
exit 0
